"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[901],{622:function(e,t,r){/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var o=r(2265),n=Symbol.for("react.element"),l=(Symbol.for("react.fragment"),Object.prototype.hasOwnProperty),a=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,u={key:!0,ref:!0,__self:!0,__source:!0};function q(e,t,r){var o,i={},s=null,m=null;for(o in void 0!==r&&(s=""+r),void 0!==t.key&&(s=""+t.key),void 0!==t.ref&&(m=t.ref),t)l.call(t,o)&&!u.hasOwnProperty(o)&&(i[o]=t[o]);if(e&&e.defaultProps)for(o in t=e.defaultProps)void 0===i[o]&&(i[o]=t[o]);return{$$typeof:n,type:e,key:s,ref:m,props:i,_owner:a.current}}t.jsx=q,t.jsxs=q},7437:function(e,t,r){e.exports=r(622)},3890:function(e,t,r){r.d(t,{Dv:function(){return useAtomValue},KO:function(){return useAtom},b9:function(){return useSetAtom},zt:function(){return Provider}});var o=r(2265),n=r(7665);let l=(0,o.createContext)(void 0),useStore=e=>{let t=(0,o.useContext)(l);return(null==e?void 0:e.store)||t||(0,n.K7)()},Provider=({children:e,store:t})=>{let r=(0,o.useRef)();return t||r.current||(r.current=(0,n.MT)()),(0,o.createElement)(l.Provider,{value:t||r.current},e)},isPromiseLike=e=>"function"==typeof(null==e?void 0:e.then),a=o.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;if("rejected"===e.status)throw e.reason;throw e.status="pending",e.then(t=>{e.status="fulfilled",e.value=t},t=>{e.status="rejected",e.reason=t}),e});function useAtomValue(e,t){let r=useStore(t),[[n,l,u],i]=(0,o.useReducer)(t=>{let o=r.get(e);return Object.is(t[0],o)&&t[1]===r&&t[2]===e?t:[o,r,e]},void 0,()=>[r.get(e),r,e]),s=n;(l!==r||u!==e)&&(i(),s=r.get(e));let m=null==t?void 0:t.delay;return(0,o.useEffect)(()=>{let t=r.sub(e,()=>{if("number"==typeof m){setTimeout(i,m);return}i()});return i(),t},[r,e,m]),(0,o.useDebugValue)(s),isPromiseLike(s)?a(s):s}function useSetAtom(e,t){let r=useStore(t),n=(0,o.useCallback)((...t)=>{if(!("write"in e))throw Error("not writable atom");return r.set(e,...t)},[r,e]);return n}function useAtom(e,t){return[useAtomValue(e,t),useSetAtom(e,t)]}},7665:function(e,t,r){let o;r.d(t,{K7:function(){return getDefaultStore},MT:function(){return createStore},cn:function(){return atom}});let n=0;function atom(e,t){let r=`atom${++n}`,o={toString:()=>r};return"function"==typeof e?o.read=e:(o.init=e,o.read=function(e){return e(this)},o.write=function(e,t,r){return t(this,"function"==typeof r?r(e(this)):r)}),t&&(o.write=t),o}let hasInitialValue=e=>"init"in e,isActuallyWritableAtom=e=>!!e.write,l=new WeakMap,registerCancelPromise=(e,t)=>{l.set(e,t),e.catch(()=>{}).finally(()=>l.delete(e))},cancelPromise=(e,t)=>{let r=l.get(e);r&&(l.delete(e),r(t))},resolvePromise=(e,t)=>{e.status="fulfilled",e.value=t},rejectPromise=(e,t)=>{e.status="rejected",e.reason=t},isPromiseLike=e=>"function"==typeof(null==e?void 0:e.then),isEqualAtomValue=(e,t)=>!!e&&"v"in e&&"v"in t&&Object.is(e.v,t.v),isEqualAtomError=(e,t)=>!!e&&"e"in e&&"e"in t&&Object.is(e.e,t.e),hasPromiseAtomValue=e=>!!e&&"v"in e&&e.v instanceof Promise,isEqualPromiseAtomValue=(e,t)=>"v"in e&&"v"in t&&e.v.orig&&e.v.orig===t.v.orig,returnAtomValue=e=>{if("e"in e)throw e.e;return e.v},createStore=()=>{let e,t;let r=new WeakMap,o=new WeakMap,n=new Map;e=new Set,t=new Set;let getAtomState=e=>r.get(e),setAtomState=(e,t)=>{Object.freeze(t);let o=r.get(e);if(r.set(e,t),n.has(e)||n.set(e,o),hasPromiseAtomValue(o)){let e="v"in t?t.v instanceof Promise?t.v:Promise.resolve(t.v):Promise.reject(t.e);o.v!==e&&cancelPromise(o.v,e)}},updateDependencies=(e,t,r)=>{let o=new Map,n=!1;r.forEach((r,l)=>{r||l!==e||(r=t),r?(o.set(l,r),t.d.get(l)!==r&&(n=!0)):console.warn("[Bug] atom state not found")}),(n||t.d.size!==o.size)&&(t.d=o)},setAtomValue=(e,t,r)=>{let o=getAtomState(e),n={d:(null==o?void 0:o.d)||new Map,v:t};if(r&&updateDependencies(e,n,r),isEqualAtomValue(o,n)&&o.d===n.d)return o;if(hasPromiseAtomValue(o)&&hasPromiseAtomValue(n)&&isEqualPromiseAtomValue(o,n)){if(o.d===n.d)return o;n.v=o.v}return setAtomState(e,n),n},setAtomValueOrPromise=(e,t,r,n)=>{if(isPromiseLike(t)){let l;let updatePromiseDependencies=()=>{let t=getAtomState(e);if(!hasPromiseAtomValue(t)||t.v!==a)return;let n=setAtomValue(e,a,r);o.has(e)&&t.d!==n.d&&mountDependencies(e,n,t.d)},a=new Promise((e,r)=>{let o=!1;t.then(t=>{o||(o=!0,resolvePromise(a,t),e(t),updatePromiseDependencies())},e=>{o||(o=!0,rejectPromise(a,e),r(e),updatePromiseDependencies())}),l=t=>{o||(o=!0,t.then(e=>resolvePromise(a,e),e=>rejectPromise(a,e)),e(t))}});return a.orig=t,a.status="pending",registerCancelPromise(a,e=>{e&&l(e),null==n||n()}),setAtomValue(e,a,r)}return setAtomValue(e,t,r)},setAtomError=(e,t,r)=>{let o=getAtomState(e),n={d:(null==o?void 0:o.d)||new Map,e:t};return(r&&updateDependencies(e,n,r),isEqualAtomError(o,n)&&o.d===n.d)?o:(setAtomState(e,n),n)},readAtomState=(e,t)=>{let r,n;let l=getAtomState(e);if(!t&&l&&(o.has(e)||Array.from(l.d).every(([t,r])=>{if(t===e)return!0;let o=readAtomState(t);return o===r||isEqualAtomValue(o,r)})))return l;let a=new Map,u=!0;try{let t=e.read(t=>{if(t===e){let e=getAtomState(t);if(e)return a.set(t,e),returnAtomValue(e);if(hasInitialValue(t))return a.set(t,void 0),t.init;throw Error("no atom init")}let r=readAtomState(t);return a.set(t,r),returnAtomValue(r)},{get signal(){return r||(r=new AbortController),r.signal},get setSelf(){return isActuallyWritableAtom(e)||console.warn("setSelf function cannot be used with read-only atom"),!n&&isActuallyWritableAtom(e)&&(n=(...t)=>{if(u&&console.warn("setSelf function cannot be called in sync"),!u)return writeAtom(e,...t)}),n}});return setAtomValueOrPromise(e,t,a,()=>null==r?void 0:r.abort())}catch(t){return setAtomError(e,t,a)}finally{u=!1}},addAtom=e=>{let t=o.get(e);return t||(t=mountAtom(e)),t},canUnmountAtom=(e,t)=>!t.l.size&&(!t.t.size||1===t.t.size&&t.t.has(e)),delAtom=e=>{let t=o.get(e);t&&canUnmountAtom(e,t)&&unmountAtom(e)},recomputeDependents=e=>{let t=new Map,r=new WeakMap,getDependents=e=>{var t;let r=new Set(null==(t=o.get(e))?void 0:t.t);return n.forEach((t,o)=>{var n;(null==(n=getAtomState(o))?void 0:n.d.has(e))&&r.add(o)}),r},loop1=e=>{getDependents(e).forEach(o=>{o!==e&&(t.set(o,(t.get(o)||new Set).add(e)),r.set(o,(r.get(o)||0)+1),loop1(o))})};loop1(e);let loop2=e=>{getDependents(e).forEach(o=>{var n;if(o!==e){let e=r.get(o);if(e&&r.set(o,--e),!e){let e=!!(null==(n=t.get(o))?void 0:n.size);if(e){let t=getAtomState(o),r=readAtomState(o,!0);e=!isEqualAtomValue(t,r)}e||t.forEach(e=>e.delete(o))}loop2(o)}})};loop2(e)},writeAtomState=(t,...r)=>{let o=!0,n=t.write(e=>returnAtomValue(readAtomState(e)),(r,...n)=>{let l;if(r===t){if(!hasInitialValue(r))throw Error("atom not writable");let e=getAtomState(r),t=setAtomValueOrPromise(r,n[0]);isEqualAtomValue(e,t)||recomputeDependents(r)}else l=writeAtomState(r,...n);if(!o){let t=flushPending();e.forEach(e=>e({type:"async-write",flushed:t}))}return l},...r);return o=!1,n},writeAtom=(t,...r)=>{let o=writeAtomState(t,...r),n=flushPending();return e.forEach(e=>e({type:"write",flushed:n})),o},mountAtom=(e,r,n)=>{var l;let a=n||[];null==(l=getAtomState(e))||l.d.forEach((t,r)=>{let n=o.get(r);n?n.t.add(e):r!==e&&mountAtom(r,e,a)}),readAtomState(e);let u={t:new Set(r&&[r]),l:new Set};if(o.set(e,u),t.add(e),isActuallyWritableAtom(e)&&e.onMount){let{onMount:t}=e;a.push(()=>{let r=t((...t)=>writeAtom(e,...t));r&&(u.u=r)})}return n||a.forEach(e=>e()),u},unmountAtom=e=>{var r;let n=null==(r=o.get(e))?void 0:r.u;n&&n(),o.delete(e),t.delete(e);let l=getAtomState(e);l?(hasPromiseAtomValue(l)&&cancelPromise(l.v),l.d.forEach((t,r)=>{if(r!==e){let t=o.get(r);t&&(t.t.delete(e),canUnmountAtom(r,t)&&unmountAtom(r))}})):console.warn("[Bug] could not find atom state to unmount",e)},mountDependencies=(e,t,r)=>{let n=new Set(t.d.keys());null==r||r.forEach((t,r)=>{if(n.has(r)){n.delete(r);return}let l=o.get(r);l&&(l.t.delete(e),canUnmountAtom(r,l)&&unmountAtom(r))}),n.forEach(t=>{let r=o.get(t);r?r.t.add(e):o.has(e)&&mountAtom(t,e)})},flushPending=()=>{let e;for(e=new Set;n.size;){let t=Array.from(n);n.clear(),t.forEach(([t,r])=>{let n=getAtomState(t);if(n){let l=o.get(t);l&&n.d!==(null==r?void 0:r.d)&&mountDependencies(t,n,null==r?void 0:r.d),l&&!(!hasPromiseAtomValue(r)&&(isEqualAtomValue(r,n)||isEqualAtomError(r,n)))&&(l.l.forEach(e=>e()),e.add(t))}else console.warn("[Bug] no atom state to flush")})}return e};return{get:e=>returnAtomValue(readAtomState(e)),set:writeAtom,sub:(t,r)=>{let o=addAtom(t),n=flushPending(),l=o.l;return l.add(r),e.forEach(e=>e({type:"sub",flushed:n})),()=>{l.delete(r),delAtom(t),e.forEach(e=>e({type:"unsub"}))}},dev_subscribe_store:(t,r)=>{if(2!==r)throw Error("The current StoreListener revision is 2.");return e.add(t),()=>{e.delete(t)}},dev_get_mounted_atoms:()=>t.values(),dev_get_atom_state:e=>r.get(e),dev_get_mounted:e=>o.get(e),dev_restore_atoms:t=>{for(let[e,r]of t)hasInitialValue(e)&&(setAtomValueOrPromise(e,r),recomputeDependents(e));let r=flushPending();e.forEach(e=>e({type:"restore",flushed:r}))}}};"number"==typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__?++globalThis.__NUMBER_OF_JOTAI_INSTANCES__:globalThis.__NUMBER_OF_JOTAI_INSTANCES__=1;let getDefaultStore=()=>(o||(1!==globalThis.__NUMBER_OF_JOTAI_INSTANCES__&&console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"),o=createStore()),o)}}]);